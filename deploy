#!/bin/bash

RED='\e[0;31m'
GREEN='\e[0;32m'
YELLOW='\e[0;33m'
CYAN='\e[0;36m'
PURPLE='\e[0;34m'
NC='\e[0m'

config_path=data/configurations
default_optimism_repo=https://github.com/ethereum-optimism/optimism.git
default_optimism_version=op-node/v1.3.0
default_opgeth_repo=https://github.com/ethereum-optimism/op-geth.git
default_opgeth_version=v1.101304.2

set -e

check_existing_deployment() {
  if [ -d "$config_path" ] && [ "$(ls -A $config_path)" ]; then
    echo -ne "${YELLOW}WARNING${NC}: There is an existing OP Stack deployment. Would you like to ${RED}ERASE all data${NC} and continue? (y/n): "; read -r erase_decision
    if [[ "$erase_decision" == "y" ]]; then
      echo -e "${RED}Cleaning existing OP Stack deployment...${NC}"
      rm -rf ./data/*
      echo -e "${GREEN}Cleaning complete.${NC}"
    else
      echo -e "${CYAN}Exiting without making changes.${NC}"
      exit 0
    fi
  fi
}

get_l1_chain_id() {
  local rpc_url="$1"
  local chain_id_hex
  chain_id_hex="$(cast rpc eth_chainId --rpc-url "$rpc_url")" || exit 1
  chain_id_hex="${chain_id_hex//\"/}"
  echo "$((16#${chain_id_hex#*x}))"
}

detect_l1_kind() {
  local rpc_url="$1"
  local chain_id="$2"

  case "$rpc_url" in
    *alchemy.com*) echo "alchemy" ;;
    *quicknode.com*|*quiknode.pro*) [ "$chain_id" -eq 1 ] && echo "quicknode" || echo "basic" ;;
    *) echo "basic" ;;
  esac
}

get_address() {
  local key_name=$1
  local priv_key_var="${key_name}_PRIVATE_KEY"
  local address_var="${key_name}_ADDRESS"

  if [ -z "${!priv_key_var}" ]; then
    echo "Private key for $key_name not provided."
    return 1
  fi

  local address
  address="$(cast wallet address --private-key "${!priv_key_var}")" || exit 1
  eval "$address_var=$address"
}

display_addresses() {
  local max_label_width=0
  local address_width=0

  for arg in "$@"; do
    local label="${arg%%:*}:"
    local address="${arg#*:}"
    [ ${#label} -gt "$max_label_width" ] && max_label_width=${#label}
    [ ${#address} -gt "$address_width" ] && address_width=${#address}
  done

  local border_length=$((max_label_width + address_width + 4))
  local border
  border=$(printf '%*s\n' "${border_length}" '' | tr ' ' '-')

  echo -e "${CYAN}${border}${NC}"
  for arg in "$@"; do
    local label="${arg%%:*}:"
    local address="${arg#*:}"
    printf "${CYAN}| %-${max_label_width}s %s |${NC}\n" "$label" "$address"
  done
  echo -e "${CYAN}${border}${NC}"
}

handle_aws_secrets() {
  read -rp "Are you using AWS Secret Manager? (y/n): " aws_decision
  if [[ "$aws_decision" == "y" ]]; then
    read -rp "AWS Secrets Manager ARN: " AWS_SECRET_ARN
    read -rp "AWS Secrets Manager Region: " AWS_SECRET_REGION
    read -rp "AWS Key ID: " AWS_KEY_ID
    read -rp "AWS Secret: " AWS_SECRET

    if [ -z "$AWS_SECRET_ARN" ] || [ -z "$AWS_SECRET_REGION" ] || [ -z "$AWS_KEY_ID" ] || [ -z "$AWS_SECRET" ]; then
      echo "AWS Secret Manager ARN, AWS Secret Manager Region, AWS Key ID, AWS Secret are required."
      exit 1
    fi

    read -rp "Admin private key: " ADMIN_PRIVATE_KEY
    get_address "ADMIN"
    display_addresses "Admin Address:$ADMIN_ADDRESS"
  else
    read -rp "Admin private key: " ADMIN_PRIVATE_KEY
    get_address "ADMIN"

    read -rp "Batcher private key: " BATCHER_PRIVATE_KEY
    get_address "BATCHER"

    read -rp "Proposer private key: " PROPOSER_PRIVATE_KEY
    get_address "PROPOSER"

    read -rp "Sequencer private key: " SEQUENCER_PRIVATE_KEY
    get_address "SEQUENCER"

    display_addresses "Admin Address:$ADMIN_ADDRESS" "Batcher Address:$BATCHER_ADDRESS" "Proposer Address:$PROPOSER_ADDRESS" "Sequencer Address:$SEQUENCER_ADDRESS"
  fi
}

handle_celestia() {
  PS3="> "
  echo "Select data availability provider:"
  select da_provider in "Ethereum L1" "Celestia"; do
    case $da_provider in
      "Ethereum L1")
        CELESTIA_MODE=false
        break
        ;;
      "Celestia")
        CELESTIA_MODE=true
        echo "Select Celestia P2P network:"
        select celestia_chain in "mocha" "celestia"; do
          case $celestia_chain in
            "mocha")
              CELESTIA_P2P_NETWORK=mocha
              break
              ;;
          "celestia")
              CELESTIA_P2P_NETWORK=celestia
              break
              ;;
            *) echo -e "${RED}Invalid option $REPLY${NC}";;
          esac
        done

        read -rp "Celestia target folder name (default: .celestia-light-mocha-4): " TARGET_FOLDER_NAME
        TARGET_FOLDER_NAME=${TARGET_FOLDER_NAME:-.celestia-light-mocha-4}
        read -rp "Celestia keyring mnemonic: " CELESTIA_KEYRING_MNEMONIC

        [ -z "$CELESTIA_KEYRING_MNEMONIC" ] && echo "Celestia keyring mnemonic is required." && exit 1

        echo -e "${YELLOW}NOTE${NC}: Remember to fund the Celestia wallet."

        break
        ;;
      *) echo -e "${RED}Invalid option $REPLY${NC}";;
    esac
  done
}

create_env_file() {
  cat <<EOF >.env
##################################################
#              Global Configuration              #
##################################################

# SEQUENCER_MODE: 'true' enables the sequencer, runs op-batcher/op-proposer
# 'false' disables them and starts the RPC node
SEQUENCER_MODE=$SEQUENCER_MODE

# CELESTIA_MODE: 'true' uses Celestia as data availability (runs the celestia-da service)
# 'false' disables the celestia-da service and uses Ethereum L1
CELESTIA_MODE=$CELESTIA_MODE

# SKIP_DEPLOYMENT_CHECK: 'true' skips checking all deployment components, only checks genesis.json and rollup.json
# 'false' checks all components, including deploy-config.json and the deployment dir
SKIP_DEPLOYMENT_CHECK=$SKIP_DEPLOYMENT_CHECK

##################################################
#              Cloning Configuration             #
##################################################

# Repository configuration for optimism and op-geth
# If not set, defaults to the official optimism implementation

OPTIMISM_REPO_URL=${CUSTOM_OPTIMISM_REPO:-$default_optimism_repo}
OPTIMISM_BRANCH_OR_COMMIT=${CUSTOM_OPTIMISM_BRANCH_OR_COMMIT:-$default_optimism_version}

OP_GETH_REPO_URL=${CUSTOM_OPGETH_REPO:-$default_opgeth_repo}
OP_GETH_BRANCH_OR_COMMIT=${CUSTOM_OPGETH_BRANCH_OR_COMMIT:-$default_opgeth_version}

##################################################
#                 Accounts Info                  #
##################################################

# Admin account
ADMIN_PRIVATE_KEY=$ADMIN_PRIVATE_KEY

# Batcher account
BATCHER_PRIVATE_KEY=$BATCHER_PRIVATE_KEY

# Proposer account
PROPOSER_PRIVATE_KEY=$PROPOSER_PRIVATE_KEY

# Sequencer account
SEQUENCER_PRIVATE_KEY=$SEQUENCER_PRIVATE_KEY

# Contract deployer account
DEPLOYER_PRIVATE_KEY=$DEPLOYER_PRIVATE_KEY

##################################################
#              celestia-da Configuration         #
##################################################

# These variables are required when CELESTIA_MODE is true

# Skips celestia-da light node sync check
# In case the node cannot catch up with the last block for a long time
SKIP_HEALTHCHECK=false

# Necessary because it's used in the build of the celestia-da service and in celestia.env/paths.env
TARGET_FOLDER_NAME=$TARGET_FOLDER_NAME
# Necessary because it's used in the build of the celestia-da service and in celestia.env
P2P_NETWORK=$CELESTIA_P2P_NETWORK

# Used in celestia.env/paths.env
CELESTIA_KEYRING_MNEMONIC="$CELESTIA_KEYRING_MNEMONIC"
CELESTIA_ACCNAME=acc

##################################################
#              op-node Configuration             #
##################################################

# The kind of RPC provider used to inform optimal transactions receipts fetching.
# Valid options: alchemy, quicknode, infura, parity, nethermind,
# debug_geth, erigon, basic, any.
L1_RPC_KIND=$L1_KIND

# Used in opnode.env
P2P_AGENT=
P2P_ADVERTISE_IP=

##################################################
#              op-geth Configuration             #
##################################################

# The chain identifier for the L2 network
L2_CHAIN_ID=$L2_CHAIN_ID

# Used in opgeth.env
MINER_ETHERBASE_ADDRESS=
UNLOCK_ADDRESS=

# If GETH_PASSWORD is set in opgeth.env
PASSWORD=

##################################################
#              op-proposer Configuration         #
##################################################

# Used in opproposer.env
L2OO_ADDRESS=

##################################################
#               Contract Deployment              #
##################################################

# RPC URL for the L1 network to interact with
L1_RPC_URL=$L1_RPC_URL

# Name for the deployed network
DEPLOYMENT_CONTEXT=$DEPLOY_CONFIG_NAME

# Optional Tenderly details for simulation link during deployment
TENDERLY_PROJECT=
TENDERLY_USERNAME=

# Optional Etherscan API key for contract verification
ETHERSCAN_API_KEY=

##################################################
#               AWS Credentials                  #
##################################################

# AWS Secrets Manager ARN
AWS_SECRET_ARN=$AWS_SECRET_ARN

# AWS Credentials
AWS_ACCESS_KEY_ID=$AWS_ACCESS_KEY_ID
AWS_SECRET_ACCESS_KEY=$AWS_SECRET_ACCESS_KEY
AWS_DEFAULT_REGION=$AWS_DEFAULT_REGION
EOF
}

deploy_new_opstack() {
  check_existing_deployment
  read -rp "L1 RPC URL: " L1_RPC_URL

  [ -z "$L1_RPC_URL" ] && echo "L1 RPC URL is required." && exit 1

  L1_CHAIN_ID=$(get_l1_chain_id "$L1_RPC_URL")
  L1_KIND=$(detect_l1_kind "$L1_RPC_URL" "$L1_CHAIN_ID")
  echo -e "L1 Chain ID: $L1_CHAIN_ID (Detected as ${GREEN}$L1_KIND${NC})"
  read -rp "L2 chain ID (default: 42069): " L2_CHAIN_ID
  L2_CHAIN_ID=${L2_CHAIN_ID:-42069}

  read -rp "Use custom optimism monorepo (default: $default_optimism_repo <-> $default_optimism_version)? (y/n): " custom_optimism_decision

  if [[ "$custom_optimism_decision" == "y" ]]; then
    read -rp "Custom optimism monorepo URL: " CUSTOM_OPTIMISM_REPO
    read -rp "Custom optimism branch/tag/commit: " CUSTOM_OPTIMISM_BRANCH_OR_COMMIT

    if [ -z "$CUSTOM_OPTIMISM_REPO" ] || [ -z "$CUSTOM_OPTIMISM_BRANCH_OR_COMMIT" ]; then
      echo "Custom optimism monorepo URL and branch/tag/commit are required."
      exit 1
    fi
  fi

  read -rp "Use custom op-geth repository (default: $default_opgeth_repo <-> $default_opgeth_version)? (y/n): " custom_opgeth_decision

  if [[ "$custom_opgeth_decision" == "y" ]]; then
    read -rp "Custom op-geth monorepo URL: " CUSTOM_OPGETH_REPO
    read -rp "Custom op-geth branch/tag/commit: " CUSTOM_OPGETH_BRANCH_OR_COMMIT

    if [ -z "$CUSTOM_OPGETH_REPO" ] || [ -z "$CUSTOM_OPGETH_BRANCH_OR_COMMIT" ]; then
      echo "Custom op-geth monorepo URL and branch/tag/commit are required."
      exit 1
    fi
  fi

  read -rp "Deploy config name (default: getting-started): " DEPLOY_CONFIG_NAME
  DEPLOY_CONFIG_NAME=${DEPLOY_CONFIG_NAME:-getting-started}
  handle_aws_secrets

  read -rp "Deployer private key (default: ADMIN_PRIVATE_KEY): " DEPLOYER_PRIVATE_KEY
  DEPLOYER_PRIVATE_KEY=${DEPLOYER_PRIVATE_KEY:-$ADMIN_PRIVATE_KEY}
  get_address "DEPLOYER"
  display_addresses "Deployer Address:$DEPLOYER_ADDRESS"

  echo -e "${YELLOW}NOTE${NC}: Remember to fund the admin, batcher, proposer, and deployer wallet."

  handle_celestia

  read -rp "Confirm deployment? (y/n): " confirm_deployment
  if [[ "$confirm_deployment" == "y" ]]; then
    echo "Generating .env and running docker compose up..."
    create_env_file
    ./run
  else
    echo -e "${RED}Deployment cancelled.${NC}"
  fi
}

load_end() {
  # shellcheck source=/dev/null
  source .env
}

restore_existing_opstack_node() {
  echo "Not implemented yet."
}

launch_existing_opstack_node() {
  if [ ! -f ".env" ]; then
    echo "File .env not found."
    restore_existing_opstack_node
    return
  fi

  load_end

  if [ -z "$BATCHER_PRIVATE_KEY" ] || [ -z "$PROPOSER_PRIVATE_KEY" ] || [ -z "$SEQUENCER_PRIVATE_KEY" ]; then
    if [ -z "$AWS_SECRET_ARN" ] || [ -z "$AWS_ACCESS_KEY_ID" ] || [ -z "$AWS_SECRET_ACCESS_KEY" ] || [ -z "$AWS_DEFAULT_REGION" ]; then
      echo "Either BATCHER_PRIVATE_KEY, PROPOSER_PRIVATE_KEY, SEQUENCER_PRIVATE_KEY or AWS_SECRET_ARN, AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY, AWS_DEFAULT_REGION are required."
      restore_existing_opstack_node
      return
    fi
  fi

  echo "Your currently Global Configuration in .env:"
  echo -e "${PURPLE}SEQUENCER_MODE${NC}: $SEQUENCER_MODE ('true' enables the sequencer, runs op-batcher/op-proposer, 'false' disables them and starts the RPC node)"
  echo -e "${PURPLE}SKIP_DEPLOYMENT_CHECK${NC}: $SKIP_DEPLOYMENT_CHECK ('true' skips checking all deployment components, only checks genesis.json and rollup.json. Suitable for RPC node)"

  echo -e "${YELLOW}NOTE${NC}: You can change these options if you select 'y'. Press Enter or type 'n' to skip."
  read -rp "Update these options in the .env file (y/n)? " update_decision

  if [[ "$update_decision" == "y" ]]; then
    for var in SEQUENCER_MODE SKIP_DEPLOYMENT_CHECK; do
      read -rp "$var (true/false): " value
      if grep -q "^$var=" ".env"; then
        sed -i "s/^$var=.*/$var=$value/" ".env"
      else
        echo "$var=$value" >> ".env"
      fi
    done
  fi

  load_end

  if [ "$SKIP_DEPLOYMENT_CHECK" = "true" ]; then
    if [ -f "$config_path/genesis.json" ] && [ -f "$config_path/rollup.json" ]; then
      ./run
    else
      echo "Required config files (genesis.json, rollup.json) not found."
      exit 1
    fi
  else
    if [ -f "$config_path/genesis.json" ] && [ -f "$config_path/rollup.json" ] && [ -f "$config_path/deploy-config.json" ] && [ -d "data/deployments/$DEPLOYMENT_CONTEXT" ]; then
      ./run
    else
      echo "Required config files (genesis.json, rollup.json, deploy-config.json) or deployment dir not found."
      exit 1
    fi
  fi
}

main() {
  echo "###################################################################################"
  echo "#              Welcome to opstack-compose OP Stack launcher by Upnode             #"
  echo "###################################################################################"
  echo ""

  PS3="Choose what you want to do: "
  options=("Deploy a new OP Stack chain" "Launch a node for an existing OP Stack chain" "Backup OP stack deployment config")
  select opt in "${options[@]}"
  do
    case $opt in
      "Deploy a new OP Stack chain")
        SEQUENCER_MODE=true
        SKIP_DEPLOYMENT_CHECK=false
        deploy_new_opstack
        break
        ;;
      "Launch a node for an existing OP Stack chain")
        launch_existing_opstack_node
        break
        ;;
      "Backup OP stack deployment config")
        echo "Not implemented yet."
        break
        ;;
      *) echo -e "${RED}Invalid option $REPLY${NC}";;
    esac
  done
}

main
